#! /usr/bin/env ruby
# #! allows the terminal to execute the script using the specified interpreter
require 'pg'
require 'date'
require 'pry'

# CLI: Parses the arguments passed via the command line and calls the appropriate methods.
class CLI
  attr_reader :app

  def initialize
    @app = ExpenseData.new
  end

  def run(arguments)
    command = arguments.first

    case command
    when 'list'
      app.list
    when 'search'
      term = ARGV[1]
      abort 'You must specify a search term!' unless term
      
      app.search(term)
    when 'add'
      amount, memo = ARGV.slice(1, 2)
      abort "You must specify an amount and a description!" unless amount && memo

      app.add(amount, memo)
    when 'delete'
      id = ARGV[1]
      abort 'You must specify an ID!' unless id

      app.delete(id)
    else
      display_help
    end
  end

  def display_help
    puts <<~HELP
      An expense tracking system!

      Supported Commands:

      add AMOUNT MEMO - Record a new expense.
      clear           - Delete all expenses.
      list            - List all expenses.
      delete NUMBER   - Delete the expense with the id NUMBER.
      search STRING   - List any expenses whose memo matches STRING.
    HELP
  end
end

# ExpenseData: Sends queries to the DB, formats and displays the returned data
class ExpenseData 
  attr_reader :connection

  def initialize
    @connection = PG.connect(dbname: 'expenses')
  end

  # Read
  def list
    result = connection.exec("SELECT * FROM expenses ORDER BY created_on;")
    abort 'You have no expenses.' if result.ntuples.zero?

    display(result)
  end

  def search(term)
    sql = "SELECT * FROM expenses WHERE memo ILIKE $1 ORDER BY created_on;"
    result = connection.exec_params(sql, ["%#{term}%"])
    abort 'No results found.' if result.ntuples.zero?
    
    display(result)
  end

  # Create
  def add(amount, memo)
    date = Date.today
    sql = "INSERT INTO expenses(amount, memo, created_on)
           VALUES($1, $2, $3)"

    connection.exec_params(sql, [amount, memo, date])
  end

  # Delete
  def delete(id)
    # Input: integer id
    # Output: Delete the expense from expenses where id = id 
    # - "That expense (id = __) does not exist!" if 

    # Check if id exists in expenses
    # If it does, delete 
    # Otherwise, abort with an error message
    target_expense = connection.exec_params("SELECT * FROM expenses WHERE id = $1", [id])
    
    if target_expense.ntuples.zero?
      puts "That expense (id = #{id}) does not exist!"
    else
      connection.exec_params("DELETE FROM expenses WHERE id = $1", [id])
    
      memo = target_expense.field_values('Memo').first
      puts "Expense ##{id} (#{memo}) was deleted:"
      display(target_expense)
    end
  end

  private 

  # Display methods
  def display(result)
    column_widths = column_widths(result)

    display_columns(result, column_widths)
     
    display_rows(result, column_widths)
  end

  def column_widths(result)
    result.fields.each_with_object({}) do |column, hash|
      longest_value_length = result.field_values(column).max_by(&:length).length
      column_width = [column.length, longest_value_length].max + 2

      hash[column] = column_width
    end
  end

  def display_columns(result, widths)
    columns = []
    divider = []

    result.fields.each do |column|
      column_width = widths[column]

      columns << column.center(column_width)
      divider << '-' * column_width
    end

    puts columns.join('|')
    puts divider.join('+')
  end

  def display_rows(result, widths)
    result.each do |tuple|
      puts tuple.map { |col, val| val.center(widths[col]) }.join('|')
    end
  end
end

CLI.new.run(ARGV)
