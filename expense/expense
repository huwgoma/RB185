#! /usr/bin/env ruby
# #! allows the terminal to execute the script using the specified interpreter
require 'pg'
require 'date'
require 'pry'

# CLI: Parses the arguments passed via the command line and calls the appropriate methods.
class CLI
  attr_reader :app

  def initialize
    @app = ExpenseData.new
  end

  def run(arguments)
    command = arguments.first

    case command
    when 'list'
      app.list
    when 'search'
      term = ARGV[1]
      abort 'You must specify a search term!' unless term
      
      app.search(term)
    when 'add'
      amount, memo = ARGV.slice(1, 2)
      abort "You must specify an amount and a description!" unless amount && memo

      app.add(amount, memo)
    else
      display_help
    end
  end

  def display_help
    puts <<~HELP
      An expense tracking system!

      Supported Commands:

      add AMOUNT MEMO - Record a new expense.
      clear           - Delete all expenses.
      list            - List all expenses.
      delete NUMBER   - Delete the expense with the id NUMBER.
      search STRING   - List any expenses whose memo matches STRING.
    HELP
  end
end

# ExpenseData: Sends queries to the DB, formats and displays the returned data
class ExpenseData 
  attr_reader :connection

  def initialize
    @connection = PG.connect(dbname: 'expenses')
  end

  def display(result)
    # Input: PG::Result


    # Output: 
    # FR: Display the returned rows
    # NFR: Display column names as well

    column_widths = result.fields.map do |column|
      max_value_length = result.field_values(column).max_by(&:length).length
      max_length = [column.length, max_value_length].max
      
      [column, max_length]
    end.to_h

    columns = result.fields.map { |column| column.rjust(column_widths[column]) }.join(' | ')
    puts columns

    result.each do |tuple|
      row = tuple.map { |column, value| value.rjust(column_widths[column]) }.join(' | ')
      puts row
    end


    # Algorithm:
    # Given a PG::Result object as input, result:
    # - Create a hash to map each column name to an integer width.
    #   - (MAP) Iterate through each column/field name. For each column:
    #     - Create a 2-element array. 
    #       1) the column name (key)
    #       2) An integer representing the length of the longest value in that 
    #          column, + 2 (?)

    # - Print out column names.
    #   - (Map) Iterate through column names. For each column:
    #     - Pad the column name to the length specified by COLWIDTHS.
    #   - Join the padded strings with ' | ' -> print 
 
    # - Print out each row.
    #   - Iterate through each row of result (hash, column => value pairs). For each row: 
    #     - (Map) Iterate through each column-value pair. For each pair:
    #       - Pad the value to the length specified by COLWIDTHS
    #     - Join with ' | ' -> print



    # Create a hash to map each column name to a column width
    # eg. 
    # { "id" => 3, "amount" => 10 }, etc.
  end 

  # Read
  def list
    result = connection.exec("SELECT * FROM expenses ORDER BY created_on;")

    display(result)

    # You have no expenses.
 
    # result.each do |tuple|
    #   values = [ 
    #     tuple['id'].rjust(5), tuple['created_on'].rjust(10),
    #     tuple['amount'].rjust(10), tuple['memo']
    #   ]

    #   puts values.join(' | ')
    # end    
  end

  def search(term)
    sql = "SELECT * FROM expenses WHERE memo ILIKE $1 ORDER BY created_on;"

    result = connection.exec_params(sql, ["%#{term}%"])

    result.each do |tuple|
      values = [ 
        tuple['id'].rjust(5), tuple['created_on'].rjust(10),
        tuple['amount'].rjust(10), tuple['memo']
      ]

      puts values.join(' | ')
    end    
    # No expenses found.
  end

  # Create
  def add(amount, memo)
    date = Date.today
    sql = "INSERT INTO expenses(amount, memo, created_on)
           VALUES($1, $2, $3)"

    connection.exec_params(sql, [amount, memo, date])
  end

  private 

  # DIsplay methods
end

CLI.new.run(ARGV)
